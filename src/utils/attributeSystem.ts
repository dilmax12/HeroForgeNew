/**
 * Sistema de Valida√ß√£o de Atributos
 * Vers√£o 3.0 - Forjador de Her√≥is
 */

import { HeroAttributes } from '../types/hero';

export const ATTRIBUTE_CONSTRAINTS = {
  MIN_ATTRIBUTE: 1,
  MAX_ATTRIBUTE: 10,
  TOTAL_POINTS: 18,
  STARTING_POINTS_PER_ATTRIBUTE: 1
};

export const ATTRIBUTE_INFO = {
  forca: {
    name: 'For√ßa',
    icon: 'üí™',
    description: 'Determina o dano f√≠sico e capacidade de carregar equipamentos pesados'
  },
  destreza: {
    name: 'Destreza',
    icon: 'üèÉ',
    description: 'Afeta precis√£o, esquiva e velocidade de movimento'
  },
  constituicao: {
    name: 'Constitui√ß√£o',
    icon: '‚ù§Ô∏è',
    description: 'Determina pontos de vida e resist√™ncia a doen√ßas'
  },
  inteligencia: {
    name: 'Intelig√™ncia',
    icon: 'üß†',
    description: 'Afeta dano m√°gico, mana e habilidades de conhecimento'
  },
  sabedoria: {
    name: 'Sabedoria',
    icon: 'ü¶â',
    description: 'Influencia percep√ß√£o, intui√ß√£o e resist√™ncia mental'
  },
  carisma: {
    name: 'Carisma',
    icon: '‚ú®',
    description: 'Determina habilidades sociais e lideran√ßa'
  }
};

/**
 * Cria atributos iniciais com valores m√≠nimos
 */
export function createInitialAttributes(): HeroAttributes {
  return {
    forca: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE,
    destreza: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE,
    constituicao: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE,
    inteligencia: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE,
    sabedoria: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE,
    carisma: ATTRIBUTE_CONSTRAINTS.STARTING_POINTS_PER_ATTRIBUTE
  };
}

/**
 * Calcula pontos restantes para distribuir
 */
export function calculateRemainingPoints(attributes: HeroAttributes): number {
  const totalUsed = Object.values(attributes).reduce((sum, value) => sum + value, 0);
  return ATTRIBUTE_CONSTRAINTS.TOTAL_POINTS - totalUsed;
}

/**
 * Valida se os atributos est√£o dentro dos limites
 */
export function validateAttributes(attributes: HeroAttributes): {
  valid: boolean;
  errors: string[];
  totalPoints: number;
  remainingPoints: number;
} {
  const errors: string[] = [];
  const totalPoints = Object.values(attributes).reduce((sum, value) => sum + value, 0);
  const remainingPoints = ATTRIBUTE_CONSTRAINTS.TOTAL_POINTS - totalPoints;

  // Verifica valores m√≠nimos
  Object.entries(attributes).forEach(([attr, value]) => {
    if (value < ATTRIBUTE_CONSTRAINTS.MIN_ATTRIBUTE) {
      errors.push(`${ATTRIBUTE_INFO[attr as keyof HeroAttributes].name} deve ter pelo menos ${ATTRIBUTE_CONSTRAINTS.MIN_ATTRIBUTE} ponto`);
    }
    if (value > ATTRIBUTE_CONSTRAINTS.MAX_ATTRIBUTE) {
      errors.push(`${ATTRIBUTE_INFO[attr as keyof HeroAttributes].name} n√£o pode ter mais que ${ATTRIBUTE_CONSTRAINTS.MAX_ATTRIBUTE} pontos`);
    }
  });

  // Verifica total de pontos
  if (totalPoints > ATTRIBUTE_CONSTRAINTS.TOTAL_POINTS) {
    errors.push(`Total de pontos (${totalPoints}) excede o limite de ${ATTRIBUTE_CONSTRAINTS.TOTAL_POINTS}`);
  }

  if (totalPoints < ATTRIBUTE_CONSTRAINTS.TOTAL_POINTS) {
    errors.push(`Voc√™ ainda tem ${remainingPoints} pontos para distribuir`);
  }

  return {
    valid: errors.length === 0,
    errors,
    totalPoints,
    remainingPoints
  };
}

/**
 * Verifica se √© poss√≠vel aumentar um atributo
 */
export function canIncreaseAttribute(
  attributes: HeroAttributes,
  attribute: keyof HeroAttributes
): boolean {
  const currentValue = attributes[attribute];
  const remainingPoints = calculateRemainingPoints(attributes);
  
  return currentValue < ATTRIBUTE_CONSTRAINTS.MAX_ATTRIBUTE && remainingPoints > 0;
}

/**
 * Verifica se √© poss√≠vel diminuir um atributo
 */
export function canDecreaseAttribute(
  attributes: HeroAttributes,
  attribute: keyof HeroAttributes
): boolean {
  const currentValue = attributes[attribute];
  return currentValue > ATTRIBUTE_CONSTRAINTS.MIN_ATTRIBUTE;
}

/**
 * Aumenta um atributo se poss√≠vel
 */
export function increaseAttribute(
  attributes: HeroAttributes,
  attribute: keyof HeroAttributes
): HeroAttributes {
  if (!canIncreaseAttribute(attributes, attribute)) {
    return attributes;
  }
  
  return {
    ...attributes,
    [attribute]: attributes[attribute] + 1
  };
}

/**
 * Diminui um atributo se poss√≠vel
 */
export function decreaseAttribute(
  attributes: HeroAttributes,
  attribute: keyof HeroAttributes
): HeroAttributes {
  if (!canDecreaseAttribute(attributes, attribute)) {
    return attributes;
  }
  
  return {
    ...attributes,
    [attribute]: attributes[attribute] - 1
  };
}

/**
 * Distribui pontos automaticamente de forma balanceada
 */
export function autoDistributePoints(baseAttributes?: Partial<HeroAttributes>): HeroAttributes {
  const attributes = createInitialAttributes();
  let remainingPoints = calculateRemainingPoints(attributes);
  
  // Se h√° atributos base preferidos, prioriza eles
  if (baseAttributes) {
    Object.entries(baseAttributes).forEach(([attr, bonus]) => {
      const key = attr as keyof HeroAttributes;
      const maxIncrease = Math.min(
        bonus || 0,
        ATTRIBUTE_CONSTRAINTS.MAX_ATTRIBUTE - attributes[key],
        remainingPoints
      );
      attributes[key] += maxIncrease;
      remainingPoints -= maxIncrease;
    });
  }
  
  // Distribui pontos restantes aleatoriamente
  while (remainingPoints > 0) {
    const attributeKeys = Object.keys(attributes) as (keyof HeroAttributes)[];
    const randomAttr = attributeKeys[Math.floor(Math.random() * attributeKeys.length)];
    
    if (canIncreaseAttribute(attributes, randomAttr)) {
      attributes[randomAttr]++;
      remainingPoints--;
    }
  }
  
  return attributes;
}